# Linux 内核体系结构

Linux 内核的主要用途就是为了与计算机硬件进行交互，实现对硬件部件的接口操作和编程控制， 对硬件资源进行访问调度，并为计算机上的用户程序提供一个便于使用的执行环境和通用的硬件虚拟接口。

## 5.1 Linux 内核模式

操作系统内核的结构模式主要可分为整体式的单内核模式和层次式的微内核模式，以及这两者的混合模式。本书所注释的 Linux 0.12 内核采用的是单内核模式。

在单内核模式的系统中，操作系统所提供服务的流程为：
应用主程序使用指定的参数值执行系统调用指令(int x80)，使 CPU 从用户态（ User Mode） 切换到核心态（ Kernel Model），
然后操作系统根据具体的参数值调用特定的系统调用服务程序，而这些服务程序则根据需要再调用底层的一些支持函数以完成特定的功能。
在完成了应用程序所要求的服务后，操作系统又使 CPU 从核心态切换回用户态，从而返回到应用程序中继续执行后面的指令。

单内核模式的内核也可粗略地分为三个层次：
* 调用服务的主程序层
* 执行系统调用的服务
* 支持系统调用的底层函数

![](img/单内核模式的简单结构模型.png)

对于微内核结构模式，其主要特点是**系统功能的模块化**和**消息传递。**
系统核心提供一个最基本的硬件抽象管理层和关键系统服务功能。这些关键功能主要进程/线程间通信服务、虚拟内存管理和进程调度等。
操作系统其余功能则以各种模块化的形式在用户空间中运行。因此，微内核结构的优点是系统服务偶合度低，便于系统的改进、扩展和移植。
主要缺点则是在系统运行期间需要通过消息传递方式，在微核心和系统各服务进程模块之间进行大量消息传递和同步操作，而这些操作会造成通信资源耗费和时间上的延迟。

## 5.2 Linux 内核系统体系结构

Linux 内核主要由 5 个模块构成，它们分别是：
1. 进程调度模块、
   * 进程调度模块用来负责控制进程对 CPU 资源的使用。所采取的调度策略是各进程能够公平合理地访问 CPU，同时保证内核能及时地执行硬件操作。
2. 内存管理模块、
   * 内存管理模块用于确保所有进程能够安全地共享机器主内存区，同时，内存管理模块还支持虚拟内存管理方式，使得 Linux 支持进程使用比实际内存空间更多的内存容量。并可以利用文件系统把暂时不用的内存数据块交换到外部存储设备上去，当需要时再交换回来。
3. 文件系统模块、
   * 文件系统模块用于支持对外部设备的驱动和存储。虚拟文件系统模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件设备的不同细节。从而提供并支持与其他操作系统兼容的多种文件系统格式。
4. 进程间通信模块
   * 进程间通信模块子系统用于支持多种进程间的信息交换方式。
5. 网络接口模块
    * 进程间通信模块子系统用于支持多种进程间的信息交换方式。


![](img/Linux内核系统模块结构及相互依赖关系.png)

![](img/内核结构框图.png)

## 5.3 Linux 内核对内存的管理和使用

### 5.3.1物理内存

在 Linux 0.12 内核中，为了有效地使用机器中的物理内存，在系统初始化阶段内存被划分成几个功能区域。

![](img/物理内存使用功能分布图.png)

* 其中， Linux 内核程序占据在物理内存的开始部分，
* 接下来是供硬盘或软盘等块设备使用的高速缓冲区部分（其中要扣除显示卡内存和 ROM BIOS 所占用的内存地址范围 640K--1MB）。
  * 当一个进程需要读取块设备中的数据时，系统会首先把数据读到高速缓冲区中；当有数据需要写到块设备上去时，系统也是先将数据放到高速缓冲区中，然后由块设备驱动程序写到相应的设备上。
* 内存的最后部分是供所有程序可以随时申请和使用的主内存区。内核程序在使用主内存区时，也同样首先要向内核内存管理模块提出申请，并在申请成功后方能使用。
* 对于含有 RAM 虚拟盘的系统，主内存区头部还要划去一部分，供虚拟盘存放数据。

在 Intel 80386 及以后的 CPU 中提供了两种内存管理（地址变换）系统：**内存分段系统（ Segmentation System）** 和**分页系统（ Paging System）**。
其中分页管理系统是可选择的，由系统程序员通过编程来确定是否采用。为了能有效地使用物理内存， Linux 系统同时采用了内存分段和分页管理机制

### 5.3.2 内存地址空间概念

* a. 程序（ 进程）的虚拟和逻辑地址；
   * 虚拟地址（ Virtual Address）是指由程序产生的由段选择符和段内偏移地址两个部分组成的地址。因为这两部分组成的地址并没有直接用来访问物理内存，而是需要通过分段地址变换机制处理或映射后才对应到物理内存地址上，因此这种地址被称为虚拟地址。
* b. CPU 的线性地址；
  * 线性地址（ Linear Address） 是虚拟地址到物理地址变换之间的中间层，是处理器可寻址的内存空间 （称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址
* c. 实际物理内存地址。

### 5.3.3 内存分段机制

CPU 进行地址变换（映射）的主要目的是为了解决虚拟内存空间到物理内存空间的映射问题。虚拟内存空间的含义是指一种利用二级或外部存储空间，使程序能不受实际物理内存量限制而使用内存的一种方法。通常虚拟内存空间要比实际物理内存量大得多。

那么虚拟存储管理是怎样实现的呢？原理与上述列车运行的比喻类似。
首先，当一个程序需要使用一块不存在的内存时（也即在内存页表项中已标出相应内存页面不在内存中）， CPU 就需要一种方法来得知这个情况。
这是通过 80386 的页错误异常中断来实现的。当一个进程引用一个不存在页面中的内存地址时，就会触发 CPU 产生页出错异常中断，并把引起中断的线性地址放到 CR2 控制寄存器中。
因此 处理该中断的过程就可以知道发生页异常的确切地址，从而可以把进程要求的页面从二级存储空间（比如硬盘上）加载到物理内存中。
如果此时物理内存已经被全部占用，那么可以借助二级存储空间的一部分作为交换缓冲区（ Swapper） 把内存中暂时不使用的页面交换到二级缓冲区中，然后把要求的页面调入内存中。这也就是内存管理的缺页加载机制，在 Linux 0.12 内核中是在程序 mm/memory.c 中实现


每个程序都可有若干个内存段组成。程序的逻辑地址（或称为虚拟地址）即是用于寻址这些段和段中具体地址位置。
在 Linux 0.12 中，程序逻辑地址到线性地址的变换过程使用了 CPU 的全局段描述符表 GDT 和局部段描述符表 LDT。由 GDT 映射的地址空间称为**全局地址空间**，由 LDT 映射的地址空间则称为**局部地址空间**，而这两者构成了虚拟地址的空间。

![](img/Linux系统中虚拟地址空间分配图.png)

### 5.3.4 内存分页管理

使用分页机制最普遍的场合是当系统内存实际上被分成很多凌乱的块时,它可以建立一个大而连续的内存空间映像，好让程序不用操心和管理这些分散的内存块。
分页机制增强了分段机制的性能。另外，页地址变换建立在段变换基础之上，任何分页机制的保护措施并不会取代段变换的保护措施而只是进行更进一步的检查操作

由于 Linux 0.1x 系统中内核和所有任务都共用同一个页目录表，使得任何时刻处理器线性地址空间到物理地址空间的映射函数都一样。
因此为了让内核和所有任务都不互相重叠和干扰，它们都必须从虚拟地址空间映射到线性地址空间的不同位置，即占用不同的线性地址空间范围。


对于 Linux 0.12 系统，内核设置全局描述符表 GDT 中的段描述符项数最大为 256， 其中 2 项空闲、 2 项系统使用，每个进程使用两项。
因此， 此时系统可以最多容纳(256-4)/2 =126 个任务，并且虚拟地址范围是 ((256-4)/2)* 64MB 约等于 8G。
但 0.12 内核中人工定义最大任务数 NR_TASKS = 64 个，每个任务逻辑地址范围是 64M，并且各个任务在线性地址空间中的起始位置是 (任务号)*64MB。

图中示出了当系统具有 4 个任务时的情况。
内核代码段和数据段被映射到线性地址空间的开始 16MB 部分，并且代码和数据段都映射到同一个区域，完全互相重叠。
而第 1 个任务（任务 0）是由内核“人工”启动运行的，其代码和数据包含在内核代码和数据中，因此该任务所占用的线性地址空间范围比较特殊。
任务 0 的代码段和数据段的长度是从线性地址 0 开始的 640KB 范围，其代码和数据段也完全重叠，并且与内核代码段和数据段有重叠的部分。

![](img/Linux%200.12线性地址空间的使用示意图.png)

![](img/Linux%200.12%20系统任务在虚拟空间中顺序排列所占的空间范围.png)

**请还需注意，进程逻辑地址空间中代码段（ Code Section） 和数据段（ Data Section）的概念与 CPU分段机制中的代码段和数据段不是同一个概念。** 
CPU 分段机制中段的概念确定了在线性地址空间中一个段的用途以及被执行或访问的约束和限制，每个段可以设置在 4GB 线性地址空间中的任何地方，它们可以相互独立也可以完全重叠或部分重叠。
而进程在其逻辑地址空间中的代码段和数据段则是指由编译器在编译程序和操作系统在加载程序时规定的在进程逻辑空间中顺序排列的代码区域、初始化和未初始化的数据区域以及堆栈区域。
进程逻辑地址空间中代码段和数据段等结构形式见图所示

![](img/进程代码和数据在其逻辑空间中的分布.png)

### 5.3.5 CPU多任务和保护模式

当一个任务（ 进程） 执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。 
此时处理器处于特权级最高的（ 0 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

![](img/多任务系统.png)

### 5.3.6 虚拟地址、线性地址、物理地址之间的关系

对于 Linux 0.12 内核代码和数据来说，在 head.s 程序的初始化操作中已经把内核代码段和数据段都设置成为长度为 16MB 的段。
在线性地址空间中这两个段的范围重叠，都是从线性地址 0 开始到地址 0xFFFFFF 共 16MB 地址范围。 
在该范围中含有内核所有的代码、内核段表（ GDT、 IDT、 TSS）、页目录表和内核的二级页表、内核局部数据以及内核临时堆栈（将被用作第 1 个任务即任务 0 的用户堆栈）。
其页目录表和二级页表已设置成把 0--16MB 的线性地址空间一一对应到物理地址上，占用了 4 个目录项， 即 4 个二级页表。
因此对于内核代码或数据的地址来说，我们可以直接把它们看作是物理内存中的地址。 此时内核的虚拟地址空间、线性地址空间和物理地址空间三者之间的关系可用图 5-14 来表示。

![](img/内核代码和数据段在三种地址空间的关系.png)

#### **任务 0 的地址对应关系**

任务 0 是系统中一个人工启动的第一个任务。它的代码段和数据段长度被设置为 640KB。该任务的代码和数据直接包含在内核代码和数据中，是从线性地址 0 开始的 640KB 内容，因此可以它直接使用内核代码已经设置好的页目录和页表进行分页地址变换。同样，它的代码和数据段在线性地址空间中也是重叠的。
对应的任务状态段 TSS0 也是手工预设置好的，并且位于任务 0 数据结构信息中，

![](img/任务0在三个地址空间中的关系.png)

#### 任务 1 的地址对应关系

与任务 0 类似，任务 1 也是一个特殊的任务。它的代码也在内核代码区域中。与任务 0 不同的是在线性地址空间中，系统在使用 fork()创建任务 1（ init 进程）时为存放任务 1 的二级页表而在主内存区申请了一页内存来存放，并复制了父进程（任务 0）的页目录和二级页表项。

![](img/任务1在三种地址空间中的关系.png)

#### 他任务的地址对应关系

对于被创建的从任务 2 开始的其他任务，它们的父进程都是 init（任务 1）进程。

从任务 2 开始，如果任务号以 nr 来表示，那么任务 nr 在线性地址空间中的起始位置将被设定在 nr*64MB 处。

![](img/其他任务地址空间中对应关系.png)

### 5.3.7用户申请内存的动态分配

当用户应用程序使用 C 函数库中的内存分配函数 malloc()申请内存时，这些动态申请的内存容量或大小均由高层次的 C 库函数 malloc()来进行管理，内核本身并不会插手管理。
因为内核已经为每个进程（除了任务 0 和 1，它们与内核代码一起常驻内存中）在 CPU 的 4G 线性地址空间中分配了 64MB 的空间，所以只要进程执行时寻址的范围在它的 64MB 范围内，内核也同样会通过内存缺页管理机制自动为寻址对应的页面分配物理内存页面并进行映射操作。

## 5.4 中断机制

当设备向处理器提出服务请求时，处理器会在执行完当前的一条指令后立刻应答设备的请求，并转而执行该设备的相关服务程序。当服务程序执行完成后，处理器会接着去做刚才被中断的程序。
这种处理方式就叫做中断（ Interrupt）方法，而设备向处理器发出的服务请求则称为中断请求（ IRQ - Interrupt Request）。
处理器响应请求而执行的设备相关程序则被称为中断服务程序或中断服务过程（ ISR - Interrupt Service Routine）。

### 5.4.2 80X86 微机的中断子系统

在使用 80X86 组成的微机系统中采用了 8259A 可编程中断控制器芯片。每个 8259A 芯片可以管理 8 个中断源。通过多片级联方式， 8259A 能构成最多管理 64 个中断向量的系统。

![](img/微机级联8259控制系统.png)

### 5.4.3 中断向量表

80X86 微机支持 256 个中断，对应每个中断需要安排一个中断服务程序。
在 80X86 实模式运行方式下，每个中断向量由 4 个字节组成。这 4 个字节指明了一个中断服务程序的段值和段内偏移值。因此整个向量表的长度为 1024 字节。
当 80X86 微机启动时， ROM BIOS 中的程序会在物理内存开始地址 0x0000:0x0000 处初始化并设置中断向量表，而各中断的默认中断服务程序则在 BIOS 中给出。
由于中断向量表中的向量是按中断号顺序排列，因此给定一个中断号 N，那么它对应的中断向量在内存中的位置就是 0x0000:N*4，即对应的中断服务程序入口地址保存在物理内存 0x0000:N*4 位置处

在 BIOS 执行初始化操作时，它设置了两个 8259A 芯片支持的 16 个硬件中断向量和 BIOS 提供的中断号为 0x10—0x1F 的中断调用功能向量等。
对于实际没有使用的向量则填入临时的哑中断服务程序的地址。以后在系统引导加载操作系统时会根据实际需要修改某些中断向量的值

### 5.4.4 Linux 内核的中断处理

![](img/Intel保留的中断号及含义.png)

在 Linux 系统中，则将 INT32--INT47（ 0x20--0x2F）对应于 8259A 中断控制芯片发出的硬件中断请求信号 IRQ0--IRQ15（见表 5–3 所示），并把用户程序发出的软件中断设置为 INT128（ 0x80），并称为系统调用（ System Call）。

**系统调用中断是用户程序使用操作系统资源的唯一界面接口**

![](img/Linux系统中8259A芯片中断发出的中断号列表.png)

在系统初始化时，内核会首先使用一个哑中断向量（中断描述符）对中断描述符表（ Interrupt Descriptor Table - IDT） 中所有 256 个描述符进行了默认设置。这个哑中断向量指向一个默认的“无中断”处理过程。

在设置中断描述符表 IDT 时 Linux 内核使用了中断门和陷阱门两种描述符。它们之间的区别在于对标志寄存器 EFLAGS 中的中断允许标志 IF 的影响。
* 由中断门描述符执行的中断会复位 IF 标志， 因此可以避免其它中断干扰当前中断的处理，随后的中断结束指令 iret 会从堆栈上恢复 IF 标志的原值；
* 而通过陷阱门执行的中断则不会影响 IF 标志。

### 5.4.5 标志寄存器的中断标志

为了避免竞争条件和中断对临界代码区的干扰，在 Linux 0.12 内核代码中许多地方使用了 `cli` 和 `sti` 指令。 
* cli 指令用来复位 CPU 标志寄存器中的中断标志，使得系统在执行 cli 指令后不会响应外部中断。
* sti 指令用来设置标志寄存器中的中断标志，以允许 CPU 能识别并响应外部设备发出的中断。

## 5.5 Linux 系统调用

### 5.5.1系统调用接口

系统调用（通常称为 syscalls）是 Linux 内核与上层应用程序进行交互通信的唯一接口，

![](img/应用程序、库函数、内核系统调用之间的关系.png)

### 5.5.2 系统调用处理过程

当应用程序经过库函数向内核发出一个中断调用 `int 0x80` 时，就开始执行一个系统调用。**其中寄存器 eax 中存放着系统调用号，而携带的参数可依次存放在寄存器 ebx、 ecx 和 edx 中**。
因此 Linux 0.12 内核中用户程序能够向内核最多直接传递三个参数，当然也可以不带参数。处理系统调用中断 int 0x80 的过程是程序 kernel/system_call.s 中的 system_call。

### 5.5.3Linux 系统调用的参数传递方式

* 通用寄存器传递方法， 例如寄存器 ebx、 ecx 和 edx。
  * 这种使用寄存器传递参数方法的一个明显优点就是：当进入系统中断服务 程序而保存寄存器值时，这些传递参数的寄存器也被自动地放在了内核态堆栈上，因此用不着再专门对传递参数的寄存器进行特殊处理。这种方法是 Linus 先生当时所知的最简单最快速的参数传递方法。
* 另 外还有一种使用 Intel CPU 提供的系统调用门（ System Call gate） 的参数传递方法，它在进程用户态堆栈 和内核态堆栈自动复制传递的参数。但这种方法使用起来步骤比较复杂。

## 5.6 系统时间和定时

### 5.6.1 系统时间

为了让操作系统能自动地准确提供当前时间和日期信息， PC/AT 微机系统中提供了用电池供电的实时钟 RT（ Real Time）电路支持。通常这部分电路与保存系统信息的少量 CMOS RAM 集成在一个芯片上，因此这部分电路被称为 RT/CMOS RAM 电路

### 5.6.2 系统定时

统的基本定时节拍由定时芯片产生。 在 Linux 0.12 内核的初始化过程中， PC 机的可编程定时芯片 Intel 8253（ 8254）的计数器通道 0 被设置成运行在方式 3 下（方波发生器方式），并且初始计数值 LATCH 
被设置成每隔 10 毫秒在通道 0 输出端 OUT 发出一个方波上升沿。由于 8254 芯片的时钟输入频率为 1.193180MHz，因此初始计数值 LATCH=1193180/100，约为 11931。
由于 OUT 引脚被连接到可编程中断 控制芯片的 0 级上，因此系统每隔 10 毫秒就会发出一个时钟中断请求（ IRQ0）信号。
这个时间节拍就是操作系统运行的脉搏，我们称之为 1 个系统滴答或一个系统时钟周期。因此每经过 1 个滴答时间，系统就会调用一次时钟中断处理程序（ timer_interrupt）。

## 5.7 Linux 进程控制

程序是一个可执行的文件，而进程（ process）是一个执行中的程序实例。利用分时技术，在 Linux 操作系统上同时可以运行多个进程。
分时技术的基本原理是把 CPU 的运行时间划分成一个个规定长度的时间片(time slice)，让每个进程在一个时间片内运行。当进程的时间片用完时系统就利用调度程序切换到另一个进程去运行。
因此实际上对于具有单个 CPU 的机器来说某一时刻只能运行一个进程。但由于每个进程运行的时间片很短（例如 15 个系统滴答=150 毫秒），所以表面看来好象所有进程在同时运行着

### 5.7.1 任务数据结构

内核程序通过进程表对进程进行管理，每个进程在进程表中占有一项。任务数据结构定义在头文件 include/linux/sched.h 中，称其为进程控制块 PCB（ Process Control Block）或进程描述符 PD（ Processor Descriptor）。

```c
struct task_struct {
    long state; // 任务的运行状态（ -1 不可运行， 0 可运行(就绪)， >0 已停止）。
    long counter; // 任务运行时间计数(递减)（滴答数），运行时间片。
    long priority; // 优先数。任务开始运行时 counter=priority，越大运行越长。
    long signal; // 信号位图，每个比特位代表一种信号，信号值=位偏移值+1。
    struct sigaction sigaction[32]; // 信号执行属性结构，对应信号将要执行的操作和标志信息。
    long blocked; // 进程信号屏蔽码（对应信号位图）。
    int exit_code; // 任务停止执行后的退出码，其父进程会来取。
    unsigned long start_code; // 代码段地址。
    unsigned long end_code; // 代码长度（字节数）。
    unsigned long end_data; // 代码长度 + 数据长度（字节数）。
    unsigned long brk; // 总长度（字节数）。
    unsigned long start_stack; // 堆栈段地址。
    long pid; // 进程标识号(进程号)。
    long pgrp; // 进程组号。
    long session; // 会话号。
    long leader; // 会话首领。
    int groups[NGROUPS]; // 进程所属组号。一个进程可属于多个组。
    task_struct *p_pptr; // 指向父进程的指针。
    task_struct *p_cptr; // 指向最新子进程的指针。
    task_struct *p_ysptr; // 指向比自己后创建的相邻进程的指针。
    task_struct *p_osptr; // 指向比自己早创建的相邻进程的指针。
    unsigned short uid; // 用户标识号（用户 id）。
    unsigned short euid; // 有效用户 id。
    unsigned short suid; // 保存的用户 id。
    unsigned short gid; // 组标识号（组 id）。
    unsigned short egid; // 有效组 id。
    unsigned short sgid; // 保存的组 id。
    long timeout; // 内核定时器超时值。
    long alarm; // 报警定时值（滴答数）。
    long utime; // 用户态运行时间（滴答数）。
    long stime; // 系统态运行时间（滴答数）。
    long cutime; // 子进程用户态运行时间。
    long cstime; // 子进程系统态运行时间。
    long start_time; // 进程开始运行时刻。
    struct rlimit rlim[RLIM_NLIMITS]; // 进程资源使用统计数组。
    unsigned int flags; // 各进程的标志（还未使用）。
    unsigned short used_math; // 标志：是否使用了协处理器。
    int tty; // 进程使用 tty 终端的子设备号。 -1 表示没有使用。
    unsigned short umask; // 文件创建属性屏蔽位。
    struct m_inode * pwd; // 当前工作目录 i 节点结构指针。
    struct m_inode * root; // 根目录 i 节点结构指针。
    struct m_inode * executable; // 执行文件 i 节点结构指针。
    struct m_inode * library; // 被加载库文件 i 节点结构指针。
    unsigned long close_on_exec; // 执行时关闭文件句柄位图标志。（参见 include/fcntl.h）
    struct file * filp[NR_OPEN]; // 文件结构指针表，最多 32 项。表项号即是文件描述符的值。
    struct desc_struct ldt[3]; // 局部描述符表。 0-空， 1-代码段 cs， 2-数据和堆栈段 ds&ss。
    struct tss_struct tss; // 进程的任务状态段信息结构。
};
```

![](img/PCB说明.png)

![](img/PCB说明2.png)

![](img/PCB说明3.png)

![](img/进程指针间的关系.png)

### 5.7.2 进程运行状态

一个进程在其生存期内，可处于一组不同的状态下，称为进程状态。 在某一时刻， Linux 下的一个进程可处于五种状态之一

如果进程正在等待使用 CPU 或者进程正被运行，则称其处于就绪状态或运行状态。
此时 state 的值是 TASK_RUNNING。如果进程正在等待某一事件的发生因而处于等待（睡眠）状态，则称其处于可中断的睡眠状态或不可中断的睡眠状态。此时 state 的值分别是 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE。如果一个进程已经被终止执行，但其还为完全释放内核资源，则称其处于僵死状态。此时该进程的 state 字段值为 TASK_ZOMBIE。
如果进程暂时被停止，则称其处于停止状态。此时 state 值为 TASK_STOPPED。

![](img/进程状态和转换关系.png)

```text

// 这里定义了进程运行时可能处的状态。
46 #define TASK_RUNNING 0 // 进程正在运行或已准备就绪。
47 #define TASK_INTERRUPTIBLE 1 // 进程处于可中断等待状态。
48 #define TASK_UNINTERRUPTIBLE 2 // 进程处于不可中断等待状态，主要用于 I/O 操作等待。
49 #define TASK_ZOMBIE 3 // 进程处于僵死状态，已经停止运行，但父进程还没发信号。
50 #define TASK_STOPPED 4 // 进程已停止。
```

* **运行状态（ 0， TASK_RUNNING）**
当进程正在被 CPU 执行，或已经准备就绪随时可由调度程序执行，则称该进程为处于运行状态 （ running）。
若此时进程没有被 CPU 执行，则称其处于就绪状态。 图 5-21 中间从上到下 3 个圆圈数值均为 0，都是就绪状态（运行状态）。 进程可以在内核态运行，也可以在用户态运行。
当一个进程在内核代码中运行时，我们称其处于内核运行态，或简称为内核态；当一个进程正在执行用户自己的代码时，我们称其为处于用户运行态（用户态）。
当系统资源已经可用时，进程就被唤醒而进入准备运行状态，该状态称为就绪态。这些状态（图中中间一列）在内核中表示方法相同，都被称为
处于 TASK_RUNNING 状态。当一个新进程刚被创建出后就处于本状态中（最下一个 0 处）。
* **可中断睡眠状态（ 1， TASK_INTERRUPTIBLE）**
当进程处于可中断等待（睡眠）状态时，系统不会调度该进程执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以唤醒进程转换到就绪状态（即可运行状态）。
* **不可中断睡眠状态（ 2， TASK_UNINTERRUPTIBLE）**
除了不会因为收到信号而被唤醒，该状态与可中断睡眠状态类似。但处于该状态的进程只有被使用 wake_up() 函数明确唤醒时才能转换到可运行的就绪状态，不会被任何信号唤醒。 
处于该状态的进程通常是在直接或间接地等待硬件条件的满足，并且常在进程需要不受干扰地等待或者所等待事件会很快发生时使用。 
* **僵死状态（ 3， TASK_ZOMBIE）**
  当进程已停止运行，但其父进程还没有调用 wait()询问其状态时，则称该进程处于僵死状态。为了
  让父进程能够获取其停止运行的信息，此时子进程的任务数据结构信息还需要保留着。一旦父进程
  调用 wait()取得了子进程的信息，则处于该状态进程的任务数据结构就会被释放掉。 
* **暂停状态（ 4， TASK_STOPPED）**
  当进程收到一个相关信号时（例如 SIGSTOP、 SIGTSTP、 SIGTTIN 或 SIGTTOU） 就会进入暂停状
  态。可向其发送 SIGCONT 信号让进程转换到可运行状态。进程在调试期间接收到任何信号均会进
  入该状态。 在 Linux 0.12 中，还未实现对该状态的转换处理。处于该状态的进程将被作为进程终止
  来处理。

### 5.7.3 进程初始化

在 boot/目录中，引导程序把内核从磁盘上加载到内存中，并让系统进入保护模式下运行后，就开始执行系统初始化程序 init/main.c。
该程序首先确定如何分配使用系统物理内存，然后调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。
在完成了这些操作之后，系统各部分已经处于可运行状态。此后程序把自己“手工”移动到任务 0（进程 0）中运行，并使用 fork()调用首次创建出进程 1。
在进程 1 中程序将继续进行应用环境的初始化并执行 shell 登录程序。而原进程 0 则会在系统空闲时被调度执行，此时任务 0 仅执行 pause()系统调用，其中又会去执行调度函数。

### 5.7.4 创建新进程

Linux 系统中创建新进程需要使用 fork()系统调用。系统正常运行起来后创建的所有进程都起源于进程 0，都是进程 0 的子进程。

在创建新进程的过程中，系统首先在任务数组中找出一个还没有被任何进程使用的空项（空槽）。
如果系统已经有 64 个进程在运行，则 fork()系统调用会因为任务数组表中没有可用空项而出错返回。 
否则系统就会为新建进程在主内存区中申请一页内存来存放其任务数据结构信息，并复制当前进程任务数据结构中的所有内容作为新进程任务数据结构的模板。
为了防止这个还未处理完成的新建进程被调度函数执行，此时应该立刻将新进程状态置为不可中断的等待状态（ TASK_UNINTERRUPTIBLE）。

后对复制的任务数据结构进行修改。把当前进程设置为新进程的父进程，清除信号位图并复位新
进程各统计值，并设置初始运行时间片值为 15 个系统滴答数（ 150 毫秒）。接着根据当前进程设置任务
状态段（ TSS）中各寄存器的值。由于创建进程时新进程返回值应为 0，所以需要设置 tss.eax = 0。新建
进程内核态堆栈指针 tss.esp0 被设置成新进程任务数据结构所在内存页面的顶端，而堆栈段 tss.ss0 被设
置成内核数据段选择符。 tss.ldt 被设置为局部表描述符在 GDT 中的索引值。如果当前进程使用了协处理
器，则还需要把协处理器的完整状态保存到新进程的 tss.i387 结构中。


此后系统设置新任务的代码和数据段基址、限长，并复制当前进程内存分页管理的页表。注意，此
时系统并不为新的进程分配实际的物理内存页面，而是让它共享其父进程的内存页面。只有当父进程或
新进程中任意一个有写内存操作时，系统才会为执行写操作的进程分配相关的独自使用的内存页面。这
种处理方式称为写时复制（ Copy On Write）技术。有关该技术的详细说明，请参见内存管理一章中的写时复制机制。

随后，如果父进程中有文件是打开的，则应将对应文件的打开次数增 1。接着在 GDT 中设置新任务
的 TSS 和 LDT 描述符项，其中基地址信息指向新进程任务结构中的 tss 和 ldt。最后再将新任务设置成
可运行状态并返回新进程号。


### 5.7.5 进程调度

内核中的调度程序用于选择系统中下一个要运行的进程。这种选择运行机制是多任务操作系统的基础。
调度程序可以看作为在所有处于运行状态的进程之间分配 CPU 运行时间的管理代码。 
由前面描述可知， Linux 进程是抢占式的，但被抢占的进程仍然处于 TASK_RUNNING 状态，只是暂时没有被 CPU 运行。
**进程的抢占发生在进程处于用户态执行阶段，在内核态执行时是不能被抢占的。**

进程切换
每当选择出一个新的可运行进程时， schedule()函数就会调用定义在 include/asm/system.h 中的 switch_to()宏执行实际进程切换操作。
该宏会把 CPU 的当前进程状态（上下文）替换成新进程的状态。 在进行切换之前， switch_to()首先检查要切换到的进程是否就是当前进程，如果是则什么也不做，直接退出。
否则就首先把内核全局变量 current 置为新任务的指针，然后长跳转到新任务的任务状态段 TSS 组成的地址处，造成 CPU 执行任务切换操作。
此时 CPU 会把其所有寄存器的状态保存到当前任务寄存器 TR 中 TSS 段选择符所指向的当前进程任务数据结构的 tss 结构中，然后把新任务状态段选择符所指向的新任务数据结构中 tss 结构中的寄存器信息恢复到 CPU 中，系统就正式开始运行新切换的任务了。
这个过程可参见图 5-23 ：

![](img/任务切换操作示意图.png)

### 5.7.6 终止进程

当一个进程结束了运行或在半途中终止了运行，那么内核就需要释放该进程所占用的系统资源。这
包括进程运行时打开的文件、申请的内存等。

当一个用户程序调用 exit()系统调用时，就会执行内核函数 do_exit()。该函数会首先释放进程代码段和数据段占用的内存页面，关闭进程打开着的所有文件，对进程使用的当前工作目录、根目录和运行程序的 i 节点进行同步操作。
如果进程有子进程，则让 init 进程作为其所有子进程的父进程。 
如果进程是一个会话头进程并且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号 SIGHUP， 这通常会终止该会话中的所有进程。
然后把进程状态置为僵死状态 TASK_ZOMBIE。并向其原父进程发送 SIGCHLD 信号，通知其某个子进程已经终止。
最后 do_exit()调用调度函数去执行其他进程。由此可见在进程被终止时，它的任务数据结构仍然保留着。因为其父进程还需要使用其中的信息。

在子进程在执行期间，父进程通常使用 wait()或 waitpid()函数等待其某个子进程终止。
当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己进程中。
最终释放已终止子进程任务数据结构所占用的内存页面，并置空子进程在任务数组中占用的指针项

## 5.8 Linux 系统中堆栈的使用方法

Linux 0.12 系统中共使用了四种堆栈。
* 一种是系统引导初始化时临时使用的堆栈；
* 一种是进入保护模式之后提供内核程序初始化使用的堆栈，位于内核代码地址空间固定位置处。该堆栈也是后来任务 0 使用的用户态堆栈；
* 另一种是每个任务通过系统调用，执行内核程序时使用的堆栈，我们称之为任务的内核态堆栈。每个任务都有自己独立的内核态堆栈；
* 最后一种是任务在用户态执行的堆栈，位于任务（进程）逻辑地址空间近末端处。

### 5.8.1 Linux 系统中堆栈的使用方法

#### 开机初始化时(bootsect.s， setup.s)

当 bootsect 代码被 ROM BIOS 引导加载到物理内存 0x7c00 处时，并没有设置堆栈段，当然程序也没有使用堆栈。
直到 bootsect 被移动到 0x9000:0 处时，才把堆栈段寄存器 SS 设置为 0x9000，堆栈指针 esp 寄存器设置为 0xff00，也即堆栈顶端在 0x9000:0xff00 处，参见 boot/bootsect.s 第 61、 62 行。
setup.s 程序中也沿用了 bootsect 中设置的堆栈段。这就是系统初始化时临时使用的堆栈

#### 进入保护模式时(head.s)

从 head.s 程序起，系统开始正式在保护模式下运行。
此时堆栈段被设置为内核数据段（ 0x10），堆栈指针 esp 设置成指向 user_stack 数组的顶端（参见 head.s，第 31 行），保留了 1 页内存（ 4K）作为堆栈使用。 
user_stack 数组定义在 sched.c 的 67--72 行，共含有 1024 个长字。它在物理内存中的位置示意图可参见下图 5-24 所示。
此时该堆栈是内核程序自己使用的堆栈。 图中给出的地址是大约值，它们与编译时的实际设置参数有关。这些地址位置可从编译内核时生成的 system.map 文件中查到

![](img/刚进入保护模式时内核使用的堆栈示意图.png)

#### 初始化时(main.c)

在 init/main.c 程序中， 在执行 move_to_user_mode()代码把控制权移交给任务 0 之前， 系统一直使用上述堆栈。
而在执行过 move_to_user_mode()之后， main.c 的代码被“切换”成任务 0 中执行。通过执行 fork()系统调用， main.c 中的 init()将在任务 1 中执行，并使用任务 1 的堆栈。
而 main()本身则在被“切换” 成为任务 0 后，仍然继续使用上述内核程序自己的堆栈作为任务 0 的用户态堆栈。

### 5.8.2 任务的堆栈

每个任务都有两个堆栈，分别用于用户态和内核态程序的执行，并且分别称为**用户态堆栈**和**内核态堆栈**。
除了处于不同 CPU 特权级中，这两个堆栈之间的主要区别在于任务的内核态堆栈很小，所保存的数据量最多不能超过（ 4096 – 任务数据结构块）个字节，大约为 3K 字节。
而任务的用户态堆栈却可以在用户的 64MB 空间内延伸。

**在用户态运行时**

每个任务（除了任务 0 和任务 1）有自己的 64MB 地址空间。当一个任务（进程）刚被创建时，它的用户态堆栈指针被设置在其地址空间的靠近末端（ 64MB 顶端）部分。 
实际上末端部分还要包括执行程序的参数和环境变量，然后才是用户堆栈空间，见图 5-25 所示。 
应用程序在用户态下运行时就一直使用这个堆栈。堆栈实际使用的物理内存则由 CPU 分页机制确定。
由于 Linux 实现了写时复制功能（ Copy on Write） ，因此在进程被创建后，若该进程及其父进程都没有使用堆栈，则两者共享同一堆栈对应的物理内存页面。
只有当其中一个进程执行堆栈写操作（例如 push 操作）时内核内存管理程序才会为写操作进程分配新的内存页面。 而进程 0 和进程 1 的用户堆栈比较特殊，见后面说明。

![](img/逻辑空间中的用户态堆栈.png)

**在内核态运行时**

每个任务有其自己的内核态堆栈，用于任务在内核代码中执行期间。其所在线性地址中的位置由该任务 TSS 段中 ss0 和 esp0 两个字段指定。
ss0 是任务内核态堆栈的段选择符， esp0 是堆栈栈低指针。
因此每当任务从用户代码转移进入内核代码中执行时，任务的内核态栈总是空的。
任务内核态堆栈被设置在位于其任务数据结构所在页面的末端，即与任务的任务数据结构（ task_struct） 放在同一页面内。
这是在建立新任务时， fork()程序在任务 tss 段的内核级堆栈字段（ tss.esp0 和 tss.ss0）中设置的，参见 kernel/fork.c， 92 行：

```C
p->tss.esp0 = PAGE_SIZE + (long)p;
p->tss.ss0 = 0x10;
```

![](img/进程的内核态堆栈示意图.png)

**任务 0 和任务 1 的堆栈**

任务 0（空闲进程 idle） 和任务 1（初始化进程 init） 的堆栈比较特殊，需要特别予以说明。
任务 0 和任务 1 的代码段和数据段相同，限长也都是 640KB，但它们被映射到不同的线性地址范围中。
任务 0 的段基地址从线性地址 0 开始，而任务 1 的段基地址从 64MB 开始。
但是它们全都映射到物理地址 0--640KB 范 围 中 。
这 个 地 址 范 围 也 就 是 内 核 代 码 和 基 本 数 据 所 存 放 的 地 方 。 在 执 行 了 move_to_user_mode()之后， 任务 0 和任务 1 的内核态堆栈分别位于各自任务数据结构所在页面的末端，
而任务 0 的用户态堆栈就是前面进入保护模式后所使用的堆栈，即 sched.c 的 user_stack[]数组的位置。
由于任务 1 在创建时复制了任务 0 的用户堆栈，因此刚开始时任务 0 和任务 1 共享使用同一个用户堆栈空间。
但是当任务 1 开始运行时，由于任务 1 映射到 user_stack[]处的页表项被设置成只读，使得任务 1 在执行堆栈操作时将会引起写页面异常，从而内核会使用写时复制机制为任务 1 另行分配主内存区页面作为堆栈空间使用。
只有到此时，任务 1 才开始使用自己独立的用户堆栈内存页面。
因此任务 0 的堆栈需要在任务 1 实际开始使用之前保持“干净”，即任务 0 此时不能使用堆栈，以确保复制的堆栈页面中不含有任务 0 的数据。

### 5.8.3 任务内核态堆栈与用户态堆栈之间的切换

在 Linux 0.12 系统中，所有中断服务程序都属于内核代码。 
如果一个中断产生时任务正在用户代码中执行，那么该中断就会引起 CPU 特权级从 3 级到 0 级的变化，此时 CPU 就会进行用户态堆栈到内核态堆栈的切换操作。 
CPU 会从当前任务的任务状态段 TSS 中取得新堆栈的段选择符和偏移值。
因为中断服务程序在内核中，属于 0 级特权级代码，所以 48 比特的内核态堆栈指针会从 TSS 的 ss0 和 esp0 字段中获得。
在定位了新堆栈（内核态堆栈）之后， CPU 就会首先把原用户态堆栈指针 ss 和 esp 压入内核态堆栈，随后把标志寄存器 eflags 的内容和返回位置 cs、 eip 压入内核态堆栈。

内核的系统调用是一个软件中断，因此任务调用系统调用时就会进入内核并执行内核中的中断服务代码。
此时内核代码就会使用该任务的内核态堆栈进行操作。 
同样， 当进入内核程序时，由于特权级别发生了改变（从用户态转到内核态），用户态堆栈的堆栈段和堆栈指针以及 eflags 会被保存在任务的内核态堆栈中。
而在执行 iret 退出内核程序返回到用户程序时，将恢复用户态的堆栈和 eflags。

![](img/用户态和内核态堆栈的切换.png)

## 5.9 Linux 0.12 采用的文件系统

内核代码若要正常运行就需要文件系统的支持。用于向内核提供最基本信息和支持的是根文件系统， 即 Linux 系统引导启动时，默认使用的文件系统是根文件系统。其中包括操作系统最起码的一些配置文件和命令执行程序。 对于 Linux 系统中使用的 UNIX 类文件系统，其中主要包括一些规定的目录、配置文件、设备驱动程序、开发程序以及所有其他用户数据或文本文件等。 一般都包括以下一些子目录和文件：

```text
etc/ 目录主要含有一些系统配置文件；
dev/ 含有设备特殊文件，用于文件操作语句操作设备；
bin/ 存放系统执行程序。例如 sh、 mkfs、 fdisk 等；
usr/ 存放库函数、手册和其他一些文件；
usr/bin 存放用户常用的普通命令；
var/ 用于存放系统运行时可变的数据或者是日志等信息。
```

## 5.10 Linux 内核源代码的目录结构

![](img/LInux 内核源代码目录结构.png)
```text
├─boot
├─fs
├─include
│  ├─asm
│  ├─linux
│  └─sys
├─init
├─kernel
│  ├─blk_drv
│  │  └─RCS
│  ├─chr_drv
│  └─math
├─lib
├─mm
└─tools

```

### 5.10.1 内核主目录 linux

linux 目录是源代码的主目录。 在该主目录中除了包括所有的 14 个子目录以外，还含有唯一的一个 Makefile 文件。
该文件是编译辅助工具软件 make 的参数配置文件。 make 工具软件的主要用途是通过识别哪些文件已被修改过，从而自动地决定在一个含有多个源程序文件的程序系统中哪些文件需要被重新编译。


# 3.1 AS 86 汇编器

Linux 1.x 使用了两种汇编器 Assembler
* 产生16位代码的as86汇编器，使用配套的ld86链接器
* GNU汇编器gas（as），使用GNU ld链接器来产生目标文件

## 3.1.1 as86汇编语言语法

_Linux 系统仅使用 as86 和 ld86 编译和链接上面提到的两个 16 位汇编程序 bootsect.s 和 setup.s_

```
as [选项] -o objfile srcfile
```

汇编器编译产生的目标文件 objfile 通常起码包含三个段或区（ section），即正文段（ .text）、数据段（ .data）和未初始化数据段（ .bss）。

正文段（或称为代码段）是一个已初始化过的段，通常其中包含程序的执行代码和只读数据。
数据段也是一个已初始化过的段，其中包含有可读/写的数据。
而未初始化数据段是一个未初始化的段。通常汇编器产生的输出目标文件中不会为该段保留空间，但在目标文件链接成执行程序被加载时操作系统会把该段的内容全部初始化为 0。

在编译过程中，汇编语言程序中会产生代码或数据的语句，都会在这三个中的一个段中生成代码或数据。编译产生的字节会从'.text'段开始存放。

```text
! 直接寄存器寻址。跳转到 bx 值指定的地址处，即把 bx 的值拷贝到 IP 中。
mov bx,ax
jmp bx
! 间接寄存器寻址。 bx 值指定内存位置处的内容作为跳转的地址。
mov [bx],ax
jmp [bx]
! 把立即数 1234 放到 ax 中。把 msg1 地址值放到 ax 中。
mov ax,#1234
mov ax,#msg1
! 绝对寻址。把内存地址 1234（ msg1） 处的内容放入 ax 中。
mov ax,1234
mov ax,msg1
mov ax,[msg1]
! 索引寻址。把第 2 个操作数所指内存位置处的值放入 ax 中。
mov ax,msg1[bx]
mov ax,mgs1[bx*4+si]
```

### 3.1.2 as86 汇编语言程序
```text
1 !
2 ! boot.s -- bootsect.s 的框架程序。用代码 0x07 替换串 msg1 中 1 字符，然后在屏幕第 1 行上显示。
3 !
4 .globl begtext, begdata, begbss, endtext, enddata, endbss ! 全局标识符，供 ld86 链接使用；
5 .text ! 正文段；
6 begtext:
7 .data ! 数据段；
8 begdata:
9 .bss ! 未初始化数据段；
10 begbss:
11 .text ! 正文段；
12 BOOTSEG = 0x07c0 ! BIOS 加载 bootsect 代码的原始段地址；
13
14 entry start ! 告知链接程序，程序从 start 标号处开始执行。
15 start:
16 jmpi go,BOOTSEG ! 段间跳转。 INITSEG 指出跳转段地址， 标号 go 是偏移地址。
17 go: mov ax,cs ! 段寄存器 cs 值-->ax，用于初始化数据段寄存器 ds 和 es。
18 mov ds,ax
19 mov es,ax
20 mov [msg1+17],ah ! 0x07-->替换字符串中 1 个点符号，喇叭将会鸣一声。
21 mov cx,#20 ! 共显示 20 个字符，包括回车换行符。
22 mov dx,#0x1004 ! 字符串将显示在屏幕第 17 行、第 5 列处。
23 mov bx,#0x000c ! 字符显示属性（红色）。
24 mov bp,#msg1 ! 指向要显示的字符串（中断调用要求）。
25 mov ax,#0x1301 ! 写字符串并移动光标到串结尾处。
26 int 0x10 ! BIOS 中断调用 0x10，功能 0x13，子功能 01。
27 loop1: jmp loop1 ! 死循环。
28 msg1: .ascii "Loading system ..."! 调用 BIOS 中断显示的信息。共 20 个 ASCII 码字符。
29 .byte 13,10
30 .org 510 ! 表示以后语句从地址 510(0x1FE)开始存放。
31 .word 0xAA55 ! 有效引导扇区标志， 供 BIOS 加载引导扇区使用。
32 .text
33 endtext:
34 .data
35 enddata:
36 .bss
37 endbss:
```

作用：
该程序是一个简单的引导扇区启动程序。 编译链接产生的执行程序可以放入软盘第 1 个扇区直接用来引导计算机启动。启动后会在屏幕第 17 行、 第 5 列处显示出红色字符串"Loading system .."，并且光标下移一行。然后程序就在第 27 行上死循环

* 注释文字 `!` `;`
* `.globl` 是汇编指示符（或称为汇编伪指令、伪操作符）。汇编指示符均以一个字符`.`开始，并且不会在编译时产生任何代码.
  * 汇编指示符由一个伪操作码，后跟 0 个或多个操作数组成。例如第 4 行上的'globl'是一个伪操作码，而其后面的标号 'begtext, begdata, begbss' 等标号就是它的操作数
* 第 5 行到第 11 行上除定义了 3 个标号外，还定义了 3 个伪操作符： '.text'、 '.data'、 '.bbs'。它们分别对应汇编程序编译产生目标文件中的 3 个段，即正文段、数据段和未初始化数据段。
  * '.text'用于标识正文段的开始位置，并把切换到 text 段；
  * '.data'用于标识数据段的开始位置，并把当前段切换到 data段；
  * 而'.bbs'则用于标识一个未初始化数据段的开始，并把当前段改变成 bbs 段。
  * 因此行 5--11 用于在每个段中定义一个标号，最后再切换到 text 段开始编写随后的代码。 这里把三个段都定义在同一重叠地址 范围中，因此本示例程序实际上不分段
* 标识符'entry'是保留关键字，用于迫使链接器 ld86 在生成的可执行文件中包括进其后指定的标号'start'。通常在链接多个目标文件生成一个可执行文件时应该在其中一个汇编程序中用关键词 entry 指定一个入口标号，以便于调试。

### 3.1.3 as86 汇编语言程序的编译和链接

```text

```


### 3.1.4 as86 和 ld86 使用方法和选项

#### as86的使用方法和选项

```text
as [-03agjuw] [-b [bin]] [-lm [list]] [-n name] [-o objfile] [-s sym] srcfile

默认设置 (除了以下默认值以外，其他选项默认为关闭或无；若没有明确说明 a 标志，则不会有输出):
-3 使用 80386 的 32 位输出；
list 在标准输出上显示；
name 源文件的基本名称（即不包括'.'后的扩展名）；
各选项含义：
-0 使用 16 比特代码段；
-3 使用 32 比特代码段；
-a 开启与 GNU as、 ld 的部分兼容性选项；
-b 产生二进制文件，后面可以跟文件名；
-g 在目标文件中仅存入全局符号；
-j 使所有跳转语句均为长跳转；
-l 产生列表文件，后面可以跟随列表文件名；
-m 在列表中扩展宏定义；
-n 后面跟随模块名称（取代源文件名称放入目标文件中） ；
-o 产生目标文件，后跟目标文件名（ objfile） ；
-s 产生符号文件，后跟符号文件名；
-u 将未定义符号作为输入的未指定段的符号；
-w 不显示警告信息；
```

#### ld86的使用方法和选项

```text
对于生成 Minix a.out 格式的版本：
ld [-03Mims[-]] [-T textaddr] [-llib_extension] [-o outfile] infile...
对于生成 GNU-Minix 的 a.out 格式的版本：
ld [-03Mimrs[-]] [-T textaddr] [-llib_extension] [-o outfile] infile...
默认设置(除了以下默认值以外，其他选项默认为关闭或无):
-03 32 位输出；
outfile a.out 格式输出；
-0 产生具有 16 比特魔数的头结构，并且对-lx 选项使用 i86 子目录；
-3 产生具有 32 比特魔数的头结构，并且对-lx 选项使用 i386 子目录；
-M 在标准输出设备上显示已链接的符号；
-T 后面跟随正文基地址 (使用适合于 strtoul 的格式)；
-i 分离的指令与数据段（ I&D）输出；
-lx 将库/local/lib/subdir/libx.a 加入链接的文件列表中；
-m 在标准输出设备上显示已链接的模块；
-o 指定输出文件名，后跟输出文件名；
-r 产生适合于进一步重定位的输出；
-s 在目标文件中删除所有符号。
```